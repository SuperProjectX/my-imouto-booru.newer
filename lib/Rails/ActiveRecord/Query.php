<?phpclass ActiveRecord_Query extends ActiveRecord{    const CALC_SQL_OPTION = 'SQL_CALC_FOUND_ROWS';        const CALC_PARAM      = 'calc_rows';        const MULTIMARK_TOKEN = '<MULTIMARK>';        static private $_default_params = array(        'select',        'from',        'joins',        'conditions',        'having',        'order',        'group',        'offset',        'limit',        'page',        'per_page'    );        private $_select;        private $_from;        private $_joins;        /**     * The difference with $_where is that these are     * the non-parsed params.     */    private $_conditions;        /**     * WHERE clause.     */    private $_where;        private $_having;        private $_order;        private $_group;        private $_offset;        private $_limit;        /**     * Actual "LIMIT x, y" part.     */    private $_limit_clause;        /**     * Defaulting to false, because it will     * allow null (= page 1).     *     * @see _parse_page_params()     */    private $_page = false;        private $_per_page = null;        private $_found_rows;        private $_params;        /**     * Parameters that will be binded to the query.     */    private $_binding_params = array();        /**     * If SQL_CALC_FOUND_ROWS will be applied.     */    private $_will_calc = false;        /**     * Final built query.     */    private $_query;        /**     * PDOStatement created when calling exec();     */    private $_stmt;        /**     * If $sql is array, the query will be built, and     * binding params are inside.     * If $sql is a string, binding params can still be passed, and     * extra params are page params.     */    public function __construct($sql, array $binding_params = array(), array $extra_params = array())    {        if (is_array($sql)) {            $this->_params = $sql;            $this->_parse_params();            $this->_parse_page_params();            $this->_parse_conditions();            $this->_build_limit_clause();            $this->_build_query();            $this->_parse_multimark();        } elseif (is_string($sql)) {            $this->_query = $sql;            $this->_binding_params = $binding_params;            $this->_parse_page_params($extra_params);        } else            Rails::raise('ActiveRecord_Query_Exception', "Parameter passed to constructor must be either an array or a string, '" . gettype($params) . "' passed.");    }        public function will_calc()    {        return $this->_will_calc;    }        public function all_data()    {        return array($this->_query, $this->_binding_params);    }        public function sql()    {        return $this->_query;    }        public function execute()    {        // try {        $params = $this->_binding_params;        array_unshift($params, $this->_query);        $this->_stmt = self::execute_sql($params);        // } catch (Exception $e) {            // ActiveRecord::raise('ActiveRecord_Query,             // vde($e);        // }        if ($this->_will_calc) {            $this->_get_found_rows();        }        return $this;    }        public function error()    {        $err = $this->_stmt->errorInfo();        return $err[2];    }        public function stmt()    {        return $this->_stmt;    }        /**     * Will be used mostly by ActiveRecord_Collection     */    public function page()    {        return $this->_page;    }        /**     * Will be used mostly by ActiveRecord_Collection     */    public function per_page()    {        return $this->_per_page;    }        /**     * Will be used mostly by ActiveRecord_Collection     */    public function offset()    {        return $this->_offset;    }        public function found_rows()    {        return $this->_found_rows;    }        private function _parse_params()    {        $this->_params = array_merge($this->_default_params(), $this->_params);                $this->_params['order']  && $this->_order  = ' ORDER BY ' . $this->_params['order'];        $this->_params['group']  && $this->_group  = ' GROUP BY ' . $this->_params['group'];        $this->_params['having'] && $this->_having = ' HAVING '   . $this->_params['having'];        $this->_params['limit']  && $this->_limit_clause = " LIMIT " . $this->_params['limit'];                unset($this->_params['order'], $this->_params['group'], $this->_params['having'], $this->_params['limit']);                foreach ($this->_params as $param => $val) {            $prop = '_' . $param;                        # Silently ignore params that won't be used.            if (is_int($param)) {                if ($val == self::CALC_PARAM)                    $this->_will_calc = true;                continue;            } elseif (!property_exists($this, $prop))                continue;            $this->$prop = $val;        }                $this->_params = null;    }        private function _parse_conditions()    {        if ($this->_conditions) {            $this->_where = ' WHERE ';                        if (is_array($this->_conditions)) {                $this->_where .= array_shift($this->_conditions);                $this->_conditions && $this->_binding_params = $this->_conditions;            } else {                $this->_where .= $this->_conditions;            }        }    }        /**     * If the method receives the parameter, it's     * extra params that are used if the query received     * was already built.     */    private function _parse_page_params(array $extra_params = array())    {        if (!func_num_args()) {            if (is_bool($this->_page) && is_null($this->_per_page))                return;            elseif ($this->_page && is_null($this->_per_page))                Rails::raise('ActiveRecord_Query_Exception', "Missing 'per_page' parameter, only 'page' defined.");            elseif (is_bool($this->_page) && is_null($this->_per_page))                Rails::raise('ActiveRecord_Query_Exception', "Missing 'page' parameter, only 'per_page' defined.");                        # Anything that's not a number or lower than 1 will default to 1.            !$this->_page || $this->_page < 0 || !ctype_digit((string)$this->_page) && $this->_page = 1;                        $this->_will_calc = true;            $this->_offset = ($this->_page - 1) * $this->_per_page;            $this->_limit  = $this->_per_page;        } else {            $this->_will_calc = is_int(strpos($this->_query, self::CALC_SQL_OPTION));            if (isset($extra_params['page']) && isset($extra_params['per_page'])                && ctype_digit((string)$extra_params['page']) && ctype_digit((string)$extra_params['per_page'])                && $extra_params['page'] > 0 && $extra_params['per_page'] > 0)            {                $this->_page = $extra_params['page'];                $this->_per_page = $extra_params['per_page'];            }        }    }        private function _build_limit_clause()    {        if ($this->_offset && $this->_limit)            $this->_limit_clause = " LIMIT " . $this->_offset . ", " . $this->_limit;        elseif ($this->_limit && !$this->_offset)            $this->_limit_clause = " LIMIT " . $this->_limit;    }        private function _build_query()    {        $calc_rows = $this->_will_calc ? ' ' . self::CALC_SQL_OPTION : null;        $this->_query = 'SELECT'.$calc_rows.' '.$this->_select.' FROM '.$this->_from.$this->_joins.$this->_where.$this->_group.$this->_having.$this->_order.$this->_limit_clause;    }        private function _parse_multimark()    {        self::_parse_query_multimark($this->_query, $this->_binding_params);    }        private function _get_found_rows()    {        $row = self::query('SELECT FOUND_ROWS()');        $row = array_shift($row);        $row = array_shift($row);        $this->_found_rows = (int)$row;    }        private function _default_params()    {        $params = array_fill_keys(self::$_default_params, null);        $params['select'] = '*';        return $params;    }}